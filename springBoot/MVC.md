# MVC

MVC는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다. M, V, C 는 각각 모델, 뷰, 컨트롤러를 의미하며 각 역할에 맞게 코드를 작성하는 개발 방식이다. UI영역과 비즈니스 로직 영역으로 구분되어 결합도를 낮춰 서로에게 영향을 주지 않고 개발과 유지보수가 가능하다.

* M (Model) : 데이터 및 비즈니스를 관리하는 로직
* V (View) : 레이아웃 및 화면 처리
* C (Controller) : 모델과 뷰로 명령 전달

## Model

클라이언트의 요청을 처리하기 위한 작업을 수행하여 클라이언트에게 보내주는 작업처리의 결과 데이터

### 규칙
1. 사용하는 모든 데이터를 가지고 있어야 한다
2. 다른 컴포넌트(뷰, 컨트롤러)에 대해 어떤 정보도 알지 못해야 해서
3. 변경이 일어날 시 변경 통지에 대한 처리방법을 구혀해야 한다

## View 

사용자 인터페이스 요소를 나타내는 컴포넌트, 데이터 및 객체의 입출력을 담당하며 사용자들이 볼 수 있는 화면을 구성한다.

### 규칙
1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.
2. 다른 컴포넌트들에 대한 정보를 알아서는 안된다 (참조하거나 동작하는 것에 대해 알지 못해야 한다) 
3. 변경이 일어날 시 변경 통지에 대한 처리방법을 구혀해야 한다

## Controller

클라이언트의 요청을 직접적으로 전달받는 엔드포인트로, 모델과 뷰 사이에서 상호작용을 해준는 역할을 한다.

### 규칙
1. 모델이나 뷰에 대해 알고 있어야한다
2. 모델이나 뷰를 모니터링 해야한다

## Spring MVC

프론트 컨트롤러가 클라이언트로부터의 요청을 모두 받게되고, 실제 요청의 처리는 개별 컨트롤러 클래스(핸들러)로 위임한다. 

* DispatcherServlet : 클라이언트의 모든 요청을 한곳으로 받아 처리하는 역할, 사용자의 Request를 각각의 핸들러에 위임하는 프론트 컨트롤러역할을 수행
* HandlerAdaptor : 매핑된 컨트롤러의 실행을 요청
* Controller : 프론트 컨트롤러로 부터 HTTP 요청을 받아 처리하고 결과를 Model에 저장하고, 지정된 뷰에 Model 객체를 넘겨준다

## 동작 흐름

1. 클라이언트가 서버에 요청하면 `DispatcherServlet`클래스가 요청을 받는다
2. `@Controller`인자를 통해 등록한 요청 위임 컨트롤러를 찾아 매핑 된 컨트롤러가 존재하면 `@RequestMapping`을 통해 요청을 처리할 메서드로 이동
3. 컨트롤러는 요청을 처리한 서비스를 받아 비즈니스 로직을 서비스에게 위임
4. `Service`는 요청에 필요한 작업을 수행하고 필요한 경우 DB정보를 DTO를 통해 전달받는다
5. 전달받은 데이터를 `Controller`에 전달한다
6. `Controller`는 `Model` 객체에게 요청에 맞는 `View`정보를 담아 `DispatcherServlet`에 전송
7. `DispatcherServlet`은 `ViewResolver`에게 전달받은 `View`정보를 전달
8. `ViewResolver`는 응답할 `View`에 대한 `JSP`를 찾아 `DispatcherServlet`에게 전달한다.
9. `DispatcherServlet`은 응답할 뷰의 Render를 지시하고 `View`는 로직을 처리한다.
10. `DispatcherServlet`은 클라이언트에게 Rending된 `View`를 응답하며 요청을 마친다.

# 참조

* https://developer.mozilla.org/ko/docs/Glossary/MVC
* https://m.blog.naver.com/jhc9639/220967034588
* https://velog.io/@do_dam/Spring-MVC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%8A%A4%ED%94%84%EB%A7%81-MVC-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4